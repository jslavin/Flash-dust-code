!!****if* source/physics/sourceTerms/Cool/CoolMain/CloudyJDS
!!
!! NAME
!!
!!  Cool
!!
!! SYNOPSIS
!!
!!  Cool(integer,intent(IN)  :: blockcount,
!!       integer,dimension(blockCount), intent(IN)  :: blocklist,
!!       real,intent(IN)  :: dt,
!!       real,intent(IN)  :: time)
!!
!! DESCRIPTION
!!      Calculate the optically thin radiative cooling using a cooling/heating
!!      table generated by running Ferland et al.'s code Cloudy as a subroutine
!!      Based on the Sutherland & Dopita cooling unit.
!!
!! ARGUMENTS
!!
!!   blockcount : 
!!
!!   blocklist : 
!!
!!   dt : 
!!
!!   time : 
!!
!! AUTOGENROBODOC
!!
!!
!!***


subroutine Cool(blockCount, blockList, dt, time)

!==============================================================================
  use Cool_data, ONLY : cl_rho, cl_Xin, cl_gamma, cl_m, useCool, cl_useHeat, &
      cl_smalle, cl_Boltzmann, cl_logXT, cl_logT, cl_N, cl_dlogTdlogXT, &
      cl_Tcut

  use Grid_interface, ONLY : Grid_getBlkPtr, Grid_getBlkIndexLimits, &
    Grid_releaseBlkPtr
  use Eos_interface, ONLY : Eos_wrapped

#include "constants.h"
#include "Flash.h"

  implicit none
  
  integer,intent(IN)  :: blockCount
  integer,dimension(blockCount), intent(IN) :: blockList
  real,intent(IN) :: dt, time

  real,pointer,dimension(:,:,:,:) :: solnData
  integer, dimension(2,MDIM) :: blkLimits, blkLimitsGC
  integer :: blockID
  real            :: dtmin, dtguess
  real            :: eid, eidold, ei, ek, dedt, dens, logchiT, logT, netcool
  integer         :: i, j, k, nok, nbad, lb, n
  
  
  ! Stuff for ODE solve
  real                  :: t1, t2, dt_alt
  
  external cool_deriv

!==============================================================================
  if(.not.useCool) return


  do lb = 1, blockCount
     blockID=blockList(lb)
     call Grid_getBlkPtr(blockID,solnData)
     call Grid_getBlkIndexLimits(blockID,blkLimits,blkLimitsGC)
     do k = blkLimits(LOW,KAXIS), blkLimits(HIGH,KAXIS)
        do j = blkLimits(LOW,JAXIS), blkLimits(HIGH,JAXIS)
           do i = blkLimits(LOW,IAXIS), blkLimits(HIGH,IAXIS)
              cl_rho = solnData(DENS_VAR,i,j,k)
              !!! Make sure using the right units for e, ei !!!
              !!! 9/11/17 - I think the units are ergs/g    !!!
              eid    = solnData(EINT_VAR,i,j,k)
              ! eid = 3/2 P/rho = 3/2*chi*k*T/m where m is mean mass/particle
              eidold = eid
              ek     = 0.5*(solnData(VELX_VAR,i,j,k)**2 + &
                   solnData(VELY_VAR,i,j,k)**2 + &
                   solnData(VELZ_VAR,i,j,k)**2)

#if NSPECIES > 0
              cl_Xin    = solnData(SPECIES_BEGIN:SPECIES_BEGIN+NSPECIES-1,i,j,k)
#else
              cl_Xin    = 1.0
#endif
              cl_gamma  = solnData(GAME_VAR,i,j,k) 
              !!should really get from EOS during integ

! Start and end times (to avoid roundoff)
 
              t1     = time
              t2     = time + dt
              dt_alt = t2 - t1
              t2     = t1 + dt_alt
 
! Update the internal energy density using Adams method.
              dens = cl_rho/cl_m
              call cool_integrate(eid, dens, time, dt)
              !if(abs(eid - eidold)/eidold .gt. 0.01) then
              !    logchiT = log10(eid * cl_mubar/cl_Boltzmann * 2./3.) 
              !    call ut_hunt(cl_logXT, cl_N, logchiT, n)
              !    logT = cl_logT(n) + cl_dlogTdlogXT(n)*(logchiT - cl_logXT(n))
              !    netcool = (eid - eidold)*cl_rho/dt
              !    write(*,fmt='(1PE12.5,i4,i4,0PF8.3,1PE13.5,E13.5)') time, &
              !        i,j,logT,netcool,dens
              !endif

! If we want to store the cooling in a variable (like for a unit test or
! something) then do it here
#ifdef COOL_VAR
              ! call cool_deriv(eid, dens, dedt)
              ! in units of erg s^-1 cm^-3
              !solnData(COOL_VAR,i,j,k) = (eid - eidold)*cl_rho/dt
              ! For purposes of keeping track of total radiated energy:
              solnData(COOL_VAR,i,j,k) = (eidold - eid)
#endif              

! update the global thermodynamic quantities due to the radiative losses
              ei = max(eid, cl_smalle)
              solnData(ENER_VAR,i,j,k) = ei + ek
              solnData(EINT_VAR,i,j,k) = ei

! store the radiative loss rate -- we store it along with the
! solution variables since it is useful to be able to refine on enuc.
#ifdef ENUC_VAR
              solnData(ENUC_VAR,i,j,k) = (eid - eidold) * cl_rho / dt
#endif              
           enddo
        enddo
     enddo
     
     ! Make all thermodynamic quantities consistent with each other.
     
     call Eos_wrapped(MODE_DENS_EI,blkLimits,blockID)
     call Grid_releaseBlkPtr(blockID,solnData)
  end do
  !=============================================================================
  
  return
end subroutine Cool



!******************************************************************************

! Routine:     cool_deriv

! Description: Routine fed to odeint to supply cooling source term.
!              Interpolates from tables supplied through CoolDataModule.


subroutine cool_deriv(e, dens, dedt)

!===============================================================================

  use Cool_data, ONLY : cl_smalle, cl_Boltzmann, cl_m, cl_logXT, cl_N, &
      cl_logL, cl_logG, cl_nnH, cl_gamma, cl_rho, cl_Boltzmann, &
      cl_logT, cl_dene, cl_dlogLdlogT, cl_dlogGdlogT, cl_dnedlogT, &
      cl_dlogTdlogXT, cl_useHeat, cl_Tcut
  implicit none
  
  real, intent(INOUT) :: e, dedt
  real, intent(IN)    :: dens
  
  real    :: tmp, logL, logG, dene, chiT, logchiT, denH, logT, dlgT, edens
  
  integer            :: j, k
  integer, parameter :: m = 4
  real               :: err

  !-----------------------------------------------------------------------------
  
  ! Don't cool below the "small energy" threshold.
  ! cl_smalle should be equal to 3/2 * smallP/rho where rho is some reasonably
  ! large density - or cl_smalle = 3/2*X*k*smallT/m where smallT is the lowest
  ! temperature that we want
  if (e < cl_smalle) then
     dedt = 0.
     return
  endif
  
  logchiT = log10(e * cl_m/cl_Boltzmann * 2./3.) 
  ! chiT = P/(n*k) = XT (since e = 3/2 P/rho = 3/2 XkT/m -- see eid in Cool)
  ! where X is (n + n_e)/n, n is total density of nuclei, n is electron dens.

  call ut_hunt(cl_logXT, cl_N, logchiT, j)
  denH = dens/cl_nnH
  ! Compute the cooling rate.
  
  if (j == 0) then
     
     ! turn off cooling at low temperatures to avoid runaway
     ! use only heating
     logL = cl_logL(1)
     edens = dens*cl_dene(1)
     
     if(cl_useHeat) then
         logG = cl_logG(1)
         dedt  = (10.**logG - edens*10.**logL)/(cl_nnH*cl_m)
     else
         dedt  =  -edens*10.**logL/(cl_nnH*cl_m)
     endif
     ! If there is net cooling, the turn if off
     !!! for debugging we are turning this off
     dedt = 0. !max(dedt,0.)
     
  elseif (j == cl_N) then
     
     ! free-free thermal emission at high temperatures
     ! (Rybicki & Lightman 1979 eq. 5.15b)
     
     edens = dens*cl_dene(cl_N)
     ! T = 2/3*e*m/(chi*k) since e = 3/2 P/rho = 3/2 chi*k*T/m
     tmp   = e*cl_m/((1. + cl_dene(cl_N))*cl_Boltzmann) * 2./3.
     ! dedt  = -1.91E-27 * sqrt(tmp) * edens
     logT = log10(tmp)
     if(logT .lt. cl_logT(cl_N)) then
         print *,'error in cool_deriv, j = cl_N, but logT is too low'
         print *,'logT =',logT
     endif
     ! make it match up at high T end and have T^1/2 dependence
     ! (and ignore heating)
     !!! Test effects for debugging !!!
     !dedt  =  -edens*10.**cl_logL(cl_N)/(cl_nnH*cl_m)* &
     !    10.**((logT - cl_logT(cl_N))/2.)
     dedt = 0.
     
  else
     
     ! get temperature from interpolation
     logT = cl_logT(j) + cl_dlogTdlogXT(j)*(logchiT - cl_logXT(j))
     dlgT = (logT - cl_logT(j))
     logL = cl_logL(j) + cl_dlogLdlogT(j)*dlgT
     dene  = cl_dene(j) + cl_dnedlogT(j)*dlgT
     edens = dene*dens
     ! units are ergs/s-g, delta(e) ~ de/dt*delta(t) ~ ergs/g
     ! dedt = (cooling rate per unit volume)/rho
     if(cl_useHeat) then
         logG = cl_logG(j) + cl_dlogGdlogT(j)*dlgT
         dedt  = (10.**logG - edens*10.**logL)/(cl_nnH*cl_m)
     else
         dedt  = -edens*10.**logL/(cl_nnH*cl_m)
     endif
     ! Might want to allow for heating, i.e. dedt = 10.**logG/(cl_nnh*cl_m)
     if (logT < cl_Tcut) dedt = 0.
     
  endif
  
  return
end subroutine cool_deriv
